<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>RBM - Restricted Boltzmann Machine </title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    :root{
      --panel: #f7f7f7;
      --accent: #2b8cff;
      --muted: #666;
    }
    body { font-family: Inter, system-ui, Arial; margin: 18px; color:#222; }
    h1 { font-size:20px; margin: 0 0 12px; }
    .layout { display:flex; gap:16px; align-items:flex-start; }
    .controls { width:360px; background:var(--panel); padding:12px; border-radius:8px; box-shadow:0 1px 4px rgba(0,0,0,0.06);}
    .controls label{display:block; font-size:13px; margin-top:8px; color:var(--muted);}
    input[type="number"], select { width:100%; padding:6px 8px; margin-top:6px; box-sizing:border-box; border:1px solid #ddd; border-radius:6px; }
    button { margin-top:10px; padding:8px 10px; border-radius:6px; border:none; cursor:pointer; }
    button.primary { background:var(--accent); color:white; }
    button.ghost { background:white; border:1px solid #ddd; }
    .small { font-size:12px; color:var(--muted); margin-top:6px; }
    canvas { background: white; border:1px solid #e6e6e6; border-radius:6px; }
    .matrix { max-height:200px; overflow:auto; border:1px dashed #eee; padding:8px; margin-top:6px; background:white; border-radius:6px; }
    table{ border-collapse:collapse; width:100%; }
    td, th{ padding:4px; text-align:center; }
    .row-title { text-align:left; font-weight:600; font-size:13px; padding-left:6px; }
    .controls .row{ display:flex; gap:8px; }
    .controls .row > * { flex:1; }
    .footer{ margin-top:10px; font-size:13px; color:var(--muted); }
    a.link{ color:var(--accent); text-decoration:none; }
    #calculationPanel { width:220px; font-family: monospace; font-size:13px; background:#f7f7f7; padding:8px; border-radius:6px; border:1px solid #ddd; max-height:480px; overflow:auto; }
  </style>
</head>
<body>
  <h1>RBM - Restricted Boltzmann Machine</h1>
  <div class="layout">
    <div class="controls">
      <label>Visible neurons (n<sub>v</sub>)</label>
      <div class="row">
        <input id="nVis" type="number" min="1" max="20" value="3">
        <input id="nHidden" type="number" min="1" max="20" value="2">
      </div>
      <div class="row">
        <button id="generateBtn" class="primary">Generate network</button>
        <button id="randomBtn" class="ghost">Randomize weights</button>
      </div>

      <div class="small">Edit each visible neuron value:</div>
      <div id="visibleInputs" class="matrix"></div>

      <label>Weight matrix (rows = hidden neurons, cols = visible neurons)</label>
      <div id="weightsTable" class="matrix"></div>

      <label>Biases for hidden neurons</label>
      <div id="biasRow" class="matrix"></div>

      <label>Activation function</label>
      <select id="activation">
        <option value="sigmoid">Sigmoid</option>
        <option value="tanh">Tanh</option>
        <option value="relu">ReLU</option>
      </select>

      <div class="row" style="margin-top:8px;">
        <button id="computeBtn" class="primary">Compute →</button>
        <button id="exportBtn" class="ghost">Export config</button>
      </div>

      <div class="footer">
        <div><strong>Usage (quick):</strong></div>
        <ol style="padding-left:16px; margin:6px 0;">
          <li>Set n<sub>v</sub> and n<sub>h</sub> → Generate network.</li>
          <li>Edit visible values, weights and biases manually.</li>
          <li>Choose activation and click <em>Compute</em>. Hidden activations appear next to neurons.</li>
        </ol>
      </div>
    </div>

    <div style="position:relative;">
      <canvas id="netCanvas" width="600" height="520"></canvas>
      <div id="calculationPanel" style="position:absolute; top:10px; right:-230px;">Hidden neuron calculations</div>
    </div>
  </div>

  <script>
    const actFns = {
      sigmoid: x => 1 / (1 + Math.exp(-x)),
      tanh: Math.tanh,
      relu: x => Math.max(0, x)
    };

    let state = {
      nVis: 3,
      nHidden: 2,
      vis: [0.5, 0.8, 0.2],
      weights: [],
      biases: [],
      z: [],
      a: []
    };

    const canvas = document.getElementById('netCanvas');
    const ctx = canvas.getContext('2d');
    const calculationPanel = document.getElementById('calculationPanel');

    function clearCanvas(){ ctx.clearRect(0,0,canvas.width,canvas.height); }

    function drawNeuron(x, y, radius = 26, label = '', sub = '') {
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI*2);
      ctx.lineWidth = 2;
      ctx.strokeStyle = '#444';
      ctx.stroke();
      ctx.font = '13px Inter, Arial';
      ctx.fillStyle = '#111';
      ctx.textAlign = 'center';
      ctx.fillText(label, x, y - 6);
      ctx.font = '12px Inter, Arial';
      ctx.fillStyle = '#444';
      ctx.fillText(sub, x, y + 12);
    }

    function drawArrow(x1,y1,x2,y2, width=2, color='#000') {
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.beginPath();
      ctx.moveTo(x1,y1);
      ctx.lineTo(x2,y2);
      ctx.stroke();
      const headLen = 8;
      const angle = Math.atan2(y2-y1, x2-x1);
      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headLen * Math.cos(angle - Math.PI/6), y2 - headLen * Math.sin(angle - Math.PI/6));
      ctx.lineTo(x2 - headLen * Math.cos(angle + Math.PI/6), y2 - headLen * Math.sin(angle + Math.PI/6));
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }

    const nVisInput = document.getElementById('nVis');
    const nHiddenInput = document.getElementById('nHidden');
    const generateBtn = document.getElementById('generateBtn');
    const randomBtn = document.getElementById('randomBtn');
    const visibleContainer = document.getElementById('visibleInputs');
    const weightsTable = document.getElementById('weightsTable');
    const biasRow = document.getElementById('biasRow');
    const activationSelect = document.getElementById('activation');
    const computeBtn = document.getElementById('computeBtn');
    const exportBtn = document.getElementById('exportBtn');

    function genEmptyWeights(nH, nV, randomize=true) {
      const W = [];
      for (let h=0; h<nH; h++){
        const row = [];
        for (let v=0; v<nV; v++){
          row.push(randomize ? +(Math.random()*2 - 1).toFixed(3) : 0);
        }
        W.push(row);
      }
      return W;
    }

    function generateNetwork() {
      const nV = Math.max(1, Math.min(20, parseInt(nVisInput.value)||3));
      const nH = Math.max(1, Math.min(20, parseInt(nHiddenInput.value)||2));
      state.nVis = nV;
      state.nHidden = nH;
      if (!state.vis || state.vis.length !== nV) state.vis = Array.from({length: nV}, ()=>0.0);
      state.weights = genEmptyWeights(nH, nV, true);
      state.biases = Array.from({length:nH}, ()=> +(Math.random()*0.6 - 0.3).toFixed(3));
      state.z = Array(nH).fill(0);
      state.a = Array(nH).fill(0);
      renderControls();
      drawNetwork(); 
    }

    function renderControls(){
      visibleContainer.innerHTML = '';
      for (let i=0;i<state.nVis;i++){
        const div = document.createElement('div');
        div.style.display = 'flex'; div.style.gap = '6px'; div.style.marginBottom = '6px';
        const lbl = document.createElement('div'); lbl.className='row-title'; lbl.style.width='70px'; lbl.textContent='x'+(i+1);
        const inp = document.createElement('input'); inp.type='number'; inp.step='0.001'; inp.value=state.vis[i]; inp.className='visVal'; inp.dataset.index=i;
        inp.addEventListener('change', ()=> { state.vis[parseInt(inp.dataset.index)] = parseFloat(inp.value)||0; });
        div.appendChild(lbl); div.appendChild(inp); visibleContainer.appendChild(div);
      }

      weightsTable.innerHTML=''; const tbl=document.createElement('table'); const thead=document.createElement('thead'); const headRow=document.createElement('tr');
      headRow.appendChild(Object.assign(document.createElement('th'), {innerText:'', style:'width:80px;'}));
      for (let v=0; v<state.nVis; v++){ const th=document.createElement('th'); th.innerText='x'+(v+1); headRow.appendChild(th);}
      thead.appendChild(headRow); tbl.appendChild(thead);
      const tbody=document.createElement('tbody');
      for (let h=0; h<state.nHidden; h++){
        const tr=document.createElement('tr'); const left=document.createElement('td'); left.className='row-title'; left.innerText='h'+(h+1); tr.appendChild(left);
        for (let v=0; v<state.nVis; v++){
          const td=document.createElement('td'); const inw=document.createElement('input'); inw.type='number'; inw.step='0.001'; inw.value=state.weights[h][v]; inw.dataset.h=h; inw.dataset.v=v; inw.className='weightCell';
          inw.addEventListener('change', ()=> { state.weights[parseInt(inw.dataset.h)][parseInt(inw.dataset.v)] = parseFloat(inw.value)||0; drawNetwork(); });
          td.appendChild(inw); tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      tbl.appendChild(tbody); weightsTable.appendChild(tbl);

      biasRow.innerHTML=''; const biasTbl=document.createElement('div');
      for (let h=0; h<state.nHidden; h++){
        const div=document.createElement('div'); div.style.display='flex'; div.style.gap='6px'; div.style.marginBottom='6px';
        const lbl=document.createElement('div'); lbl.className='row-title'; lbl.style.width='70px'; lbl.innerText='b'+(h+1);
        const inb=document.createElement('input'); inb.type='number'; inb.step='0.001'; inb.value=state.biases[h]; inb.className='biasInput'; inb.dataset.h=h;
        inb.addEventListener('change', ()=> { state.biases[parseInt(inb.dataset.h)] = parseFloat(inb.value)||0; drawNetwork(); });
        div.appendChild(lbl); div.appendChild(inb); biasTbl.appendChild(div);
      }
      biasRow.appendChild(biasTbl);
    }

    function computeHidden(){
      const act=activationSelect.value;
      state.a = state.a.map(()=>0);
      let calcText = '';
      for (let h=0; h<state.nHidden; h++){
        let z=0;
        for (let v=0; v<state.nVis; v++) z += (state.vis[v]||0)*(state.weights[h][v]||0);
        z += (state.biases[h]||0);
        state.z[h] = z;
        state.a[h] = actFns[act](z);
        calcText += `h${h+1}: z=${z.toFixed(3)} → a=${state.a[h].toFixed(3)}\n`;
      }
      calculationPanel.textContent = calcText;
      drawNetwork();
    }

    function drawNetwork(){
      clearCanvas();
      const leftX=140, rightX=canvas.width-160, topOffset=60;
      const visGap=(canvas.height-topOffset*2)/(state.nVis+1), hidGap=(canvas.height-topOffset*2)/(state.nHidden+1);
      const visPos=[]; for(let i=0;i<state.nVis;i++){ const y=topOffset+(i+1)*visGap; visPos.push({x:leftX,y}); drawNeuron(leftX,y,24,'x'+(i+1),Number(state.vis[i]).toFixed(3));}
      const hidPos=[]; for(let h=0;h<state.nHidden;h++){ const y=topOffset+(h+1)*hidGap; hidPos.push({x:rightX,y});}
      let maxW=0; for(let h=0;h<state.nHidden;h++){for(let v=0;v<state.nVis;v++){maxW=Math.max(maxW,Math.abs(state.weights[h][v]||0));}} if(maxW===0) maxW=1;
      for(let h=0;h<state.nHidden;h++){for(let v=0;v<state.nVis;v++){ const w=state.weights[h][v]||0; const s=Math.min(8,1+Math.abs(w)/maxW*6); const color=w>=0?'rgba(31,119,180,0.95)':'rgba(255,127,14,0.95)'; drawArrow(visPos[v].x+26,visPos[v].y,hidPos[h].x-26,hidPos[h].y,s,color);} }
      for(let h=0;h<state.nHidden;h++){ const p=hidPos[h]; drawNeuron(p.x,p.y,28,'h'+(h+1),Number(state.a[h]).toFixed(3)); ctx.font='12px Inter, Arial'; ctx.fillStyle='#555'; ctx.fillText('b='+Number(state.biases[h]).toFixed(3),p.x,p.y+36);}
    }

    generateBtn.addEventListener('click', generateNetwork);
    computeBtn.addEventListener('click', computeHidden);
    randomBtn.addEventListener('click', ()=>{ state.weights = genEmptyWeights(state.nHidden,state.nVis,true); renderControls(); drawNetwork(); });

    generateNetwork();
  </script>
</body>
</html>
